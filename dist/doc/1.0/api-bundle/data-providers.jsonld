{"@context":"http://schema.org","@type":"CreativeWork","name":"Data providers","text":"\u003ch1\u003eData providers\u003c/h1\u003e\n\n\u003cp\u003eTo retrieve data exposed by the API, DunglasApiBundle uses classes called \u003cem\u003edata providers\u003c/em\u003e. A data provider using \u003ca href=\"http://www.doctrine-project.org/projects/orm.html\"\u003eDoctrine ORM\u003c/a\u003e to retrieve data from a database is included with the bundle and is enabled by default. This data provider natively supports paged collections and filters. It can be used as is and fits perfectly with common usages.\u003c/p\u003e\n\n\u003cp\u003eBut sometime, you want to retrieve data from other sources such as a webservice, ElasticSearch, MongoDB or another ORM.\nCustom data providers can be used to do so. A project can include as many data providers as it needs. The first able to retrieve data for a given resource will be used.\u003c/p\u003e\n\n\u003ch2\u003eCreating a custom data provider\u003c/h2\u003e\n\n\u003cp\u003eData providers must return a collection of items and specific items for a given resource when requested. In the following example, we will create a custom provider returning data from a static list of objects. Feel free to adapt it to match your own needs.\u003c/p\u003e\n\n\u003cp\u003eLet’s start with the data provider itself:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-php\"\u003e\u0026lt;?php\n\n// src/AppBundle/DataProvider/StaticDataProvider.php\n\nnamespace AppBundle\\DataProvider;\n\nuse Dunglas\\ApiBundle\\Api\\ResourceInterface;\nuse Dunglas\\ApiBundle\\Model\\DataProviderInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\nclass StaticDataProvider implements DataProviderInterface\n{\n    private $data;\n\n    public function __construct()\n    {\n        $this-\u0026gt;data = [\n            \u0026#39;a1\u0026#39; =\u0026gt; new MyEntity(\u0026#39;a1\u0026#39;, 1871),\n            \u0026#39;a2\u0026#39; =\u0026gt; new MyEntity(\u0026#39;a2\u0026#39;, 1936),\n        ];\n    }\n\n    public function getItem(ResourceInterface $resource, $id, $fetchData = false)\n    {\n        return isset($this-\u0026gt;data[$id]) ? $this-\u0026gt;data[$id] : null;\n    }\n\n    public function getCollection(ResourceInterface $resource, Request $request)\n    {\n        return $this-\u0026gt;data;\n    }\n\n    public function supports(ResourceInterface $resource)\n    {\n        return \u0026#39;AppBundle\\Entity\\MyEntity\u0026#39; === $resource-\u0026gt;getEntityClass();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThen register that provider with a priority higher than the Doctrine ORM data provider:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e\n# app/config/services.yml\n\nservices:\n    my_custom_data_provider:\n        class: AppBundle\\DataProvider\\StaticDataProvider\n        tags:  [ { name: \u0026#34;api.data_provider\u0026#34;, priority: 1 } ]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis data provider is now up and running. It will take precedence over the default Doctrine ORM data provider for each resource it supports (in this case, the resource managing \u003ccode\u003eAppBundle\\Entity\\MyEntity\u003c/code\u003e).\u003c/p\u003e\n\n\u003ch2\u003eReturning a paged collection\u003c/h2\u003e\n\n\u003cp\u003eThe previous custom data provider returns only full, non-paged collections. However for large collections, returning all\nthe data set in one response is often not possible.\nIn order to support pagination, implement a \u003ccode\u003egetCollection()\u003c/code\u003e method in your data provider that would return a \u003ccode\u003eDunglas\\ApiBundle\\Model\\PaginatorInterface\u003c/code\u003e instead of an array.\u003c/p\u003e\n\n\u003cp\u003eTo create your own paginators, take a look at the Doctrine ORM paginator bridge: \u003ca href=\"/Doctrine/Orm/Paginator.php\"\u003e\u003ccode\u003eDunglas\\ApiBundle\\Doctrine\\Orm\\Paginator\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch2\u003eSupporting filters\u003c/h2\u003e\n\n\u003cp\u003eTo be able \u003ca href=\"filters.jsonld\"\u003eto filter collections\u003c/a\u003e, the Data Provider must be aware of registered filters to the given resource.\nThe best way to learn how to create a filter aware data provider is too look at the default Doctrine ORM data provider: \u003ca href=\"/Doctrine/Orm/DataProvider.php\"\u003e\u003ccode\u003eDunglas\\ApiBundle\\Doctrine\\Orm\\DataProvider\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch2\u003eExtending the Doctrine Data Provider\u003c/h2\u003e\n\n\u003cp\u003eThe bundle ships with a data provider leveraging the Doctrine ORM. This default data provider can be extended.\u003c/p\u003e\n\n\u003cp\u003eFor performance reasons, \u003ca href=\"http://www.doctrine-project.org/jira/browse/DDC-3282\"\u003ecustom output walkers for the Doctrine ORM Paginator\u003c/a\u003e\nare disabled. It drastically improves performance when dealing with large collections. However it prevents advanced \u003ca href=\"filters.jsonld\"\u003efilters\u003c/a\u003e\nadding \u003ccode\u003eHAVING\u003c/code\u003e and \u003ccode\u003eGROUP BY\u003c/code\u003e clauses to DQL queries to work properly.\u003c/p\u003e\n\n\u003cp\u003eTo enable custom output walkers, start by creating a custom data provider supporting the \u003ccode\u003eAppBundle\\Entity\\MyEntity\u003c/code\u003e class:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-php\"\u003e\u0026lt;?php\n\n// src/AppBundle/DataProvider/MyEntityDataProvider.php\n\nnamespace AppBundle\\DataProvider;\n\nuse Dunglas\\ApiBundle\\Doctrine\\Orm\\DataProvider;\nuse Dunglas\\ApiBundle\\Model\\DataProviderInterface;\n\nclass MyEntityDataProvider extends DataProvider\n{\n    protected function getPaginator(QueryBuilder $queryBuilder)\n    {\n        $doctrineOrmPaginator = new DoctrineOrmPaginator($queryBuilder);\n        // Enable output walkers to make queries with HAVING and ORDER BY clauses working\n        $doctrineOrmPaginator-\u0026gt;setUseOutputWalkers(true);\n\n        return new Paginator($doctrineOrmPaginator);\n    }\n\n    public function supports(ResourceInterface $resource)\n    {\n        return \u0026#39;AppBundle\\Entity\\MyEntity\u0026#39; === $resource-\u0026gt;getEntityClass();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThen register the data provider:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e\n# app/config/services.yml\n\nservices:\n    my_entity_data_provider:\n        parent: \u0026#34;api.doctrine.orm.data_provider\u0026#34;\n        class: AppBundle\\DataProvider\\MyEntityDataProvider\n        tags:  [ { name: \u0026#34;api.data_provider\u0026#34;, priority: 1 } ]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ePrevious chapter: \u003ca href=\"operations.jsonld\"\u003eOperations\u003c/a\u003e\u003cbr/\u003e\nNext chapter: \u003ca href=\"filters.jsonld\"\u003eFilters\u003c/a\u003e\u003c/p\u003e\n","author":[{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","Name":"Stepan Anchugov","email":"kixxx1@gmail.com"},{"@type":"Person","Name":"Kevin Saliou","email":"kevin@saliou.name"}],"dateCreated":"2015-09-04T11:55:15+02:00","dateModified":"2016-05-21T17:49:17+02:00"}