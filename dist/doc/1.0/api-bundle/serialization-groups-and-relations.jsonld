{"@context":"http://schema.org","@type":"CreativeWork","name":"Serialization groups and relations","text":"\u003ch1\u003eSerialization groups and relations\u003c/h1\u003e\n\n\u003ch2\u003eUsing serialization groups\u003c/h2\u003e\n\n\u003cp\u003eSymfony 2.7 introduced \u003ca href=\"http://symfony.com/blog/new-in-symfony-2-7-serialization-groups\"\u003eserialization (and deserialization) groups support\u003c/a\u003e\nin the Serializer component. Specifying to the API system the groups to use is really simple:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e# app/config/services.yml\nservices:\n    resource.product:\n        parent:    \u0026#34;api.resource\u0026#34;\n        arguments: [ \u0026#34;AppBundle\\\\Entity\\\\Product\u0026#34; ]\n        calls:\n            -      method:    \u0026#34;initNormalizationContext\u0026#34;\n                   arguments: [ { groups: [ \u0026#34;serialization_group1\u0026#34;, \u0026#34;serialization_group2\u0026#34; ] } ]\n            -      method:    \u0026#34;initDenormalizationContext\u0026#34;\n                   arguments: [ { groups: [ \u0026#34;deserialization_group1\u0026#34;, \u0026#34;deserialization_group2\u0026#34; ] } ]\n        tags:      [ { name: \u0026#34;api.resource\u0026#34; } ]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe built-in controller and the Hydra documentation generator will leverage specified serialization and deserialization\nto give access only to exposed properties and to guess if they are readable or/and writable.\u003c/p\u003e\n\n\u003ch2\u003eAnnotations\u003c/h2\u003e\n\n\u003cp\u003eThe Symfony serializer allows to specify the definition of serialization using XML, YAML, or annotations. As annotations are really easy to understand, we’ll use them in following examples.\u003cbr/\u003e\nHowever, in order to use annotations, don’t forget to enable it in the serializer configuration:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e# app/config/config.yml\nframework:\n    # ...\n    serializer:      { enable_annotations: true }\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eEmbedding relations\u003c/h2\u003e\n\n\u003cp\u003eBy default, the serializer provided with DunglasApiBundle will represent relations between objects by dereferenceables\nURIs. They allow to retrieve details of related objects by issuing an extra HTTP request.\u003c/p\u003e\n\n\u003cp\u003eIn the following JSON document, the relation from an offer to a product is represented by an URI:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \u0026#34;@context\u0026#34;: \u0026#34;/contexts/Offer\u0026#34;,\n  \u0026#34;@id\u0026#34;: \u0026#34;/offer/62\u0026#34;,\n  \u0026#34;@type\u0026#34;: \u0026#34;Offer\u0026#34;,\n  \u0026#34;price\u0026#34;: 31.2,\n  \u0026#34;product\u0026#34;: \u0026#34;/products/59\u0026#34;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eEmbedding the context\u003c/h2\u003e\n\n\u003cp\u003eBy default, the context attribute (\u003ccode\u003e@context\u003c/code\u003e) will be serialized as an URI:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \u0026#34;@context\u0026#34;: \u0026#34;/contexts/Offer\u0026#34;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eYou can also decide to embed it:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \u0026#34;@context\u0026#34;: {\n    \u0026#34;@vocab\u0026#34;: \u0026#34;http://localhost:8000/apidoc#\u0026#34;,\n    \u0026#34;hydra\u0026#34;: \u0026#34;http://www.w3.org/ns/hydra/core#\u0026#34;,\n    \u0026#34;name\u0026#34;: \u0026#34;#Offer/name\u0026#34;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eFor this, register the following services (for example in \u003ccode\u003eapp/config/services.yml\u003c/code\u003e):\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003eservices:\n    # ...\n\n    resource.offer:\n        parent:    \u0026#34;api.resource\u0026#34;\n        arguments: [ \u0026#34;AppBundle\\\\Entity\\\\Offer\u0026#34; ]\n        calls:\n            -      method:    \u0026#34;initNormalizationContext\u0026#34;\n                   arguments: [ { json_ld_context_embedded: true } ]\n        tags:      [ { name: \u0026#34;api.resource\u0026#34; } ]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3\u003eNormalization\u003c/h3\u003e\n\n\u003cp\u003eFrom a performance point of view, it’s sometimes necessary to avoid extra HTTP requests. It is possible to embed related\nobjects (or only some of their properties) directly in the parent response trough serialization groups.\nBy using the following serizalization groups annotations (\u003ccode\u003e@Groups\u003c/code\u003e) and this updated service definition, a JSON representation\nof the product is embedded in the offer response:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-php\"\u003e\u0026lt;?php\n\n// src/AppBundle/Entity/Offer.php\n\nnamespace AppBundle\\Entity;\n\nuse Symfony\\Component\\Serializer\\Annotation\\Groups;\n\nclass Offer\n{\n    // ...\n    \n    /**\n     * ...\n     * @Groups({\u0026#34;offer\u0026#34;})\n     */\n    public $price;\n    \n    /**\n     * ...\n     * @Groups({\u0026#34;offer\u0026#34;})\n     */\n    public $product;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-php\"\u003e\u0026lt;?php\n\n// src/AppBundle/Entity/Product.php\n\nnamespace AppBundle\\Entity;\n\nuse Symfony\\Component\\Serializer\\Annotation\\Groups;\n\nclass Product\n{\n    // ...\n\n    /**\n     * ...\n     * @Groups({\u0026#34;offer\u0026#34;})\n     */\n    public $name;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eRegister the following services (for example in \u003ccode\u003eapp/config/services.yml\u003c/code\u003e):\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003eservices:\n    # ...\n\n    resource.offer:\n        parent:    \u0026#34;api.resource\u0026#34;\n        arguments: [ \u0026#34;AppBundle\\\\Entity\\\\Offer\u0026#34; ]\n        calls:\n            -      method:    \u0026#34;initNormalizationContext\u0026#34;\n                   arguments: [ { groups: [ \u0026#34;offer\u0026#34; ] } ]\n        tags:      [ { name: \u0026#34;api.resource\u0026#34; } ]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe generated JSON with previous settings will be like the following:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \u0026#34;@context\u0026#34;: \u0026#34;/contexts/Offer\u0026#34;,\n  \u0026#34;@id\u0026#34;: \u0026#34;/offer/62\u0026#34;,\n  \u0026#34;@type\u0026#34;: \u0026#34;Offer\u0026#34;,\n  \u0026#34;price\u0026#34;: 31.2,\n  \u0026#34;product\u0026#34;: {\n    \u0026#34;@id\u0026#34;: \u0026#34;/products/59\u0026#34;,\n    \u0026#34;@type\u0026#34;: \u0026#34;Product\u0026#34;,\n    \u0026#34;name\u0026#34;: \u0026#34;Lyle and Scott polo skirt\u0026#34;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote: in order to optimize such embedded relations, the default doctrine dataprovider will automatically join entities whose relations are defined as \u003ca href=\"http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/annotations-reference.html#manytoone\"\u003e\u003ccode\u003eEAGER\u003c/code\u003e\u003c/a\u003e avoiding extra queries to be executed when serializing the sub-objects.\u003c/strong\u003e\u003c/p\u003e\n\n\u003ch3\u003eDenormalization\u003c/h3\u003e\n\n\u003cp\u003eIt is also possible to embed a relation in \u003ccode\u003ePUT\u003c/code\u003e and \u003ccode\u003ePOST\u003c/code\u003e requests. To enable that feature, the serialization groups must be\nset the same way as normalization and the service definition must be like the following:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e# app/config/services.yml\nservices:\n    # ...\n\n    resource.offer:\n        parent:     \u0026#34;api.resource\u0026#34;\n        arguments:  [ \u0026#34;AppBundle\\\\Entity\\\\Offer\u0026#34; ]\n        calls:\n            -       method:    \u0026#34;initDenormalizationContext\u0026#34;\n                    arguments:\n                        -      { groups: [ \u0026#34;offer\u0026#34; ] }\n        tags:       [ { name: \u0026#34;api.resource\u0026#34; } ]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe following rules apply when denormalizating embedded relations:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eif a \u003ccode\u003e@id\u003c/code\u003e key is present in the embedded resource, the object corresponding to the given URI will be retrieved trough\nthe data provider and any changes in the embedded relation will be applied to that object.\u003c/li\u003e\n\u003cli\u003eif no \u003ccode\u003e@id\u003c/code\u003e key exists, a new object will be created containing data provided in the embedded JSON document.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eYou can create as many embedding levels as you want.\u003c/p\u003e\n\n\u003ch3\u003eName conversion\u003c/h3\u003e\n\n\u003cp\u003eThe Serializer Component provides a handy way to translate or map PHP field names to serialized names. See the\n\u003ca href=\"http://symfony.com/doc/master/components/serializer.html#converting-property-names-when-serializing-and-deserializing\"\u003eSymfony documentation\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eTo use this feature, declare a new service with id \u003ccode\u003eapi.name_converter\u003c/code\u003e. For example, you can convert \u003ccode\u003eCamelCase\u003c/code\u003e to\n\u003ccode\u003esnake_case\u003c/code\u003e with the following configuration:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e# app/config/services.yml\nservices:\n    # ...\n\n    api.name_converter:\n        class: Symfony\\Component\\Serializer\\NameConverter\\CamelCaseToSnakeCaseNameConverter\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3\u003eEntity identifier case\u003c/h3\u003e\n\n\u003cp\u003eAt the moment we identify the entity identifier based on the \u003ca href=\"http://doctrine-orm.readthedocs.org/en/latest/reference/basic-mapping.html#identifiers-primary-keys\"\u003eDoctrine Identifier\u003c/a\u003e.\nWe don’t support entity resource with multiple identifier.\u003c/p\u003e\n\n\u003cp\u003eThe entity identifier is never returned like other properties : it is a part of the URI contained in the \u003ccode\u003e@id\u003c/code\u003e field.\nSo in the \u003ccode\u003e/apidoc\u003c/code\u003e endpoint the identifier will not appear in the properties list.\u003c/p\u003e\n\n\u003ch4\u003eEntity identifier writable\u003c/h4\u003e\n\n\u003cp\u003eIn some cases, you will want to set the identifier of a resource from the client (like a slug for example).\nIn this case the identifier property must become a writable class property in the \u003ccode\u003e/apidoc\u003c/code\u003e endpoint.\u003c/p\u003e\n\n\u003cp\u003eTo do this you simply have to :\n* create a setter for identifier in the entity\n* add the denormalization group to the property if you use a specific denormalization group\u003c/p\u003e\n\n\u003cp\u003ePrevious chapter: \u003ca href=\"filters.jsonld\"\u003eFilters\u003c/a\u003e\u003cbr/\u003e\nNext chapter: \u003ca href=\"validation.jsonld\"\u003eValidation\u003c/a\u003e\u003c/p\u003e\n","author":[{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","Name":"Pierre-Henri Cumenge","email":"pierrehenric@theodo.fr"},{"@type":"Person","Name":"Teoh Han Hui","email":"teohhanhui@gmail.com"},{"@type":"Person","Name":"Alexis Degrugillier","email":"alexis.degrugillier@stadline.com"},{"@type":"Person","Name":"Kevin Saliou","email":"kevin@saliou.name"},{"@type":"Person","Name":"Kevin Saliou","email":"kevin@saliou.name"},{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"}],"dateCreated":"2015-09-04T11:55:15+02:00","dateModified":"2016-05-24T13:29:13+02:00"}